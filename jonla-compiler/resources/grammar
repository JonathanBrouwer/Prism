ast Term {
    Type()
    Var(name: Input)
    Let(name: Input, arg_type: Term, arg_value: Term, body: Term)
    FunType(name: Input, arg_type: Term, body_type: Term)
    FunConstruct(name: Input, arg_type: Term, body: Term)
    FunDestruct(func: Term, arg: Term)
}

rule layout -> Input = [' ' | '\n']

rule identifier -> Input {
    $([ 'a'-'z' | 'A'-'Z' | '_' ]['a'-'z' | 'A'-'Z' | '0'-'9' | '_' ]*) {/ "Identifier"} {nolayout}
}

rule term -> Term {
    "let" n:identifier ":" t:term "=" v:term ";" b:term { Let(n, t, v, b) } /
    x:identifier ":" t:term "." r:term { FunConstruct(x, t, r) } /
    n:identifier ":" at:term "->" bt:term { FunType(n, at, bt) } /
    at:subterm "->" bt:term { FunType("_", at, bt) } /
    sub:subterm { sub }
}

rule subterm -> Term {
    f:subterm " " a:subsubterm { FunDestruct(f, a) } /
    sub:subsubterm { sub }
}

rule subsubterm -> Term {
    "Type" { Type() } /
    n:identifier { Var(n) } /
    "(" t:term() ")" { t }
}