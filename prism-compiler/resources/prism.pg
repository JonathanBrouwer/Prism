rule start = expr($Env::Nil());

rule wrapped_expr(env) = RuleAction::Value(e) <- e:expr(env);

rule expr(env) {
    group statement {
        b <- "grammar" "{" g:grammar(wrapped_expr(env)) "}" b:#adapt(g, expr(env));
        Expr::Let(env, n, v, b)
            <- "let" n:identifier "=" v:#next ";" b:#this($Env::Substitute(n, v, env));
        Expr::Let(env, n, Expr::TypeAssert(env, v, t), b)
            <- "let" n:identifier ":" t:#next "=" v:#next ";" b:#this($Env::Substitute(n, v, env));
    }
    group fnconstruct {
        Expr::FnConstruct(env, n, r) <- "(" n:identifier ":" at:#next ")" "=>" r:#this($Env::Type(n, env));
        Expr::FnConstruct(env, n, r) <- n:identifier "=>" r:#this($Env::Type(n, env));
        //fnconstruct(#this, #next);
    }
    group fntype {
        Expr::FnType(env, n, at, bt) <- "(" n:identifier ":" at:#this ")" "->" bt:#this($Env::Type(n, env));
        Expr::FnType(env, "_", at, bt) <- at:#next "->" bt:#this($Env::Type("_", env));
    }
    group assert {
        Expr::TypeAssert(env, e, typ) <- e:#next ":" typ:#next;
    }
    group fndestruct {
        Expr::FnDestruct(env, f, a) <- f:#this " " a:#next;
    }
    group base {
        t <- "(" t:expr(env) ")";
        Expr::Type(env) <- "Type";
        Expr::Name(env, n) <- n:identifier;
    }
}

rule fnconstruct(this, next) {
    FnConstruct(n, Let("_", TypeAssert(n, t), r)) <- "(" n:identifier ":" t:next ")" r:#this;
    FnConstruct(n, r) <- n:identifier r:#this;
    FnConstruct(n, Let("_", TypeAssert(n, t), r)) <- "(" n:identifier ":" t:next ")" "=>" r:this;
    FnConstruct(n, r) <- n:identifier "=>" r:this;
}

rule layout {
    [' ' | '\n'];
    "//" [^'\n']* "\n";
}

rule keyword {
    "Type";
    "grammar";
}

rule identifier {
    #[error("Identifier")]
    #[disable_layout]
    #[disable_recovery]
    n <- #neg(keyword #neg(['a'-'z' | 'A'-'Z' | '0'-'9' | '_' ]))
         n:#str([ 'a'-'z' | 'A'-'Z' | '_' ] ['a'-'z' | 'A'-'Z' | '0'-'9' | '_' ]*);
}